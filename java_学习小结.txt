方法重写(掌握)
	
(1)描述：在子类中，出现了和父类中一模一样的方法声明的现象。
	
(2)作用：可以使用父类功能，还可以增强该功能。
	
(3)面试题：
		
override和overload的区别?
		
overload可以改变返回值类型吗?
	
(4)方法重写的注意事项：
		
A:父类私有方法不能被重写
		
B:子类重写方法的访问权限不能比父类的方法低
		
C:静态只能重写静态。(其实这算不上重写)


成员内部类：
		
private：为了数据的安全性
		
static：为了让数据访问更方便

局部内部类

匿名内部类：存在一个类或者接口，其本质是匿名子类对象

==和equals()的区别?
==:
基本类型：比较的是基本类型的值是否相同
引用类型：比较的是引用类型的地址值是否相同
equals():
引用类型。默认情况下，比较的是引用类型的地址是否相同。

字符串的比较：
字符串本身也是一个类，是引用类型。
字符串类重写了该方法，比较的是字符串的内容是否相同。

字符串构造方法
public String():创建String对象

public String(byte[] bytes):把字节数组转成字符串。
public String(byte[] bytes,int index,int length):把字节数组中的一部分转成字符串
 
public String(char[] value):把字符数组转成字符串
 
public String(char[] value,int index,int count):把字符数组的一部分转成字符串
 
public String(String original):把字符串转成字符串

字符串比较：
== 比较引用类型，比较的是地址值

Arrays:针对数组进行操作的工具类。提供了排序，查找等功能。
如果数组本身是无序的，不能直接使用二分查找。
并且，先排序，再二分也是有问题的，因为这样就改变了数组中元素原始的索引位置。

StringBuffer:线程安全的可变字符串。StringBuffer的长度可变，String的长度固定。

1:String,StringBuffer,StringBuilder的区别?
 
A:String长度固定，StringBuffer和StringBuilder的长度可变。
 
B:StringBuffer线程安全，效率低。StringBuilder线程不安全，效率高。
 
2:StringBuffer和数组的区别
 
A:StringBuffer的长度可变，可以存储任意数据类型，最终结果其实是一个字符串。
 
B:数组长度固定，存储同一种数据类型的元素。


冒泡排序：
相邻元素，两两比较，大的往后放；arr[y]>arr[y+1]；

选择排序
从0开始，依次和后面的比较，小的往前放。arr[y] < arr[x]


Random:产生随机数的类
如果种子不同，随机数不同。如果种子相同，随机数相同。

为什么出现集合类?
面向对象语言对事物的体现都是以对象的形式，所以为了方便对多个对象的操作，用前面所学知识，我们只能采用对象数组实现。但是，对象数组的长度又是固定的，适应不了变化的需求，所以，java就提供了集合类供我们使用。

集合类的特点
A:长度可变
B:只能存储对象
C:可以存储不同类型的对象

数组和集合的区别
A:集合长度可变；集合只能存储引用数据类型；集合可以存储不同数据类型的元素
 
B:数组长度固定；数组可以存储引用数据类型，也可以存储基本数据类型；数组存储的是同一种数据类型的元素

由于我们的功能需求不太一样，所以，java就提供了多种集合类供我们使用。这些集合类的本质区别：其实是底层的数据结构不同。

数据结构：数据的存储方式。

ArrayList：底层数据结构是数组，查询快，增删慢，线程不安全，效率高
Vector：底层数据结构是数组，查询快，增删慢，线程安全，效率低
LinkedList：底层数据结构是链表，查询慢，增删快，线程不安全，效率高

查询多：ArrayList，增删多：LinkedList，要安全：Vector
不知道用哪个，就用ArrayList


如何在定义集合的时候，去明确集合的元素类型呢?
泛型：把明确数据类型的工作推迟到了创建对象或者调用方法的时候去做的。


在哪些地方使用泛型呢?
一般就是在集合中常见。查看API，如果类，抽象类，接口后面跟的有<?>就说明要用泛型。

泛型的好处
A:提高了程序的安全性
B:将运行期遇到的问题转移到了编译期
C:省去了类型强转的麻烦


Collection:
List:元素有序(存储和取出顺序一致)，可重复
Set:元素无序,唯一
HashSet：不保证 set 的迭代顺序，特别是它不保证该顺序恒久不变

LinkedHashSet:底层数据结构是哈希表和链表
哈希表：能够保证元素的唯一性
链表：能够保证元素有序
TreeSet:底层数据结构是二叉树,可以让元素排序，有两种方案，分别是：自然排序，以及Comparator(比较器)进行排序,具体使用哪种情况看你使用的构造方法

Set集合两个子类:
排序用TreeSet,不需要排序用HashSet,不能确定排序用HashSet



1：Collection集合体系结构
	
Collection
		
   List(元素有序，可重复)
			
       ArrayList:底层数据结构是数组，查询快,增删慢,线程不安全,效率高

       vector:底层数据结构是数组，查询快,增删慢
	,线程安全,效率低
       LinkedList:底层数据结构是链表，查询慢,增删快,线程不安全,效率高

   Set(元素无序，唯一)
       HashSet:底层数据结构是哈希表。保证元素的唯一性?
依赖两个方法hashCode()和equals()。
			          LinkedHashSet：底层数据结构是哈希表和链表，由哈希表保证元素唯一
，由链表保证元素有序
			       TreeSet：底层数据结构是二叉树(红黑树)，保证元素的唯一性?
根据比较的返回值是否是0
				                保证元素的排序?自然排序
比较器排序



2：针对Collection，你准备使用谁?

   元素唯一吗?
   
是：Set
   
      要排序吗?
 是：TreeSet
 否：HashSet


      不知道，就用HashSet
		
   否：List

      要安全吗?
      要：Vector(其实也不用，有更好的方式，后面讲)

      不要：ArrayList或者LinkedList

         查询多：ArrayList

         增删多：LinkedList
   
   不知道，就用ArrayList


3：集合中的数据结构问题
	
ArrayXxx:底层数据结构是数组，查询快，增删慢
	
LinkedXxx:底层数据结构是链表，查询慢，增删快
	
HashXxx:底层数据结构是哈希表。依赖两个方法hashCode()和equals()，根据情况选择是否自动重写
	
TreeXxx:底层数据结构是二叉树。有两种方案：自然排序，比较器排序。

Collections和Collection的区别
Collections:是针对集合进行操作的工具类。里面包含了排序和查找等方法
Collection:是单列集合的顶层接口，定义了单列集合的共性功能


Map：元素是按照键值对形式存储的。每一对元素由两部分组成。分别叫键和值, 键是唯一的，值是可以重复的。所以Map集合的底层数据结构是针对键有效，跟值无关。

Map接口和Collection接口的不同?
A:Map集合是双列集合；Map集合的键是唯一的，值是可以重复的。其实我们也可以简单的理解为Map集合的键和值是由Set和List组成；数据结构针对键有效。
B:Collection集合是单列集合；Collection集合的儿子Set是唯一的，List是可以重复的；数据结构针对元素有效。

HashMap和Hashtable的区别
HashMap是线程不安全的，效率高。允许使用null值和 null 键；
Hashtable是线程安全的，效率低。不允许使用null值和null键。

List,Set,Map等接口是否都继承自Map接口？
List,Set都继承自Collection接口；Map本身就是顶层接口。

final,finally和finalize的区别
final:修饰类，修饰成员变量，修饰成员方法；修饰类,类不能被继承；修饰成员变量，变量是常量；修饰成员方法，方法不能被重写。
finally:被finally控制的代码永远会执行，用于释放资源。注意事项：就是在执行到finally之前jvm退出了。
finalize:是Object类的方法，启动垃圾回收器，用于回收垃圾。

如果catch里面有return语句，请问finally的代码还会执行吗?如果会，请问是在return前还是return后？
会执行，前面执行。
准确的说法：中间。
整个这个过程有三步：
1：执行到return 40;的时候，就在内存中形成了一个返回路径。
2:由于它发现还有一个finally，所以，继续执行了finally，n=50
3:finally结束后，再次回到以前的返回路径，继续。所以返回的是40

文件删除功能：
如果一个文件夹内有内容，是不能直接删除的；Java程序的删除不走回收站，直接删除。

递归:方法定义中调用方法本身的现象
注意事项：A:递归一定要有出口，否则就是死递归；B:递归的次数不能过多，否则内存溢出；C:构造方法不能递归使用。

IO流分类：默认情况下，IO流分类说的是按照数据类型分
A:数据流向 输入流，读数据；输出流，写数据；
B:数据类型 字节流，字符流

IO流的四个基类：
字节流 
字节输入流	InputStream
字节输出流	OutputStream
字符流
字符输入流	Reader
字符输出流	Writer

实现数据的换行?
 
不同的系统，针对换行符号的识别是不一样的。

Mac:	\r

linux:	\n
 
windows: \r\n

一次读取一个字节数组：public int read(byte[] b):返回的是实际的读取长度，把数据读取到字节数组中

数组的方式一次比一个字节的方式快很多,设计出了内置数组的缓冲区流。
字节缓冲输入流 BufferedInputStream
字节缓冲输出流 BufferedOutputStream
通过看构造方法，我们发现，缓冲流不能直接操作文件,是建立在基本的操作流之上的。这种流也被称之为高级流。

字节流操作中文，不是特别的方便，所以我们要想办法改进。这个时候就引出了转换流。把字节流转换为字符流。
字符流 = 字节流+编码表

IO流中的编码解码问题：要想在IO流中对数据进行编码问题，必须使用转换流。

flush()和close()的区别?
A:flush 刷新流，流对象还可以继续使用
B:close 关闭流，流对象不可以继续使用

复制文本文件：
8种 
字节流	4种 基本字节流  字节缓冲流
字符流	4种 基本字符流  字符缓冲流

复制图片，视频，音频等
4种
字节流	4种 基本字节流 字节缓冲流

内存操作流：数据在内存中转一圈(ByteArrayInputStream, ByteArrayOutputStream)

为什么要有序列化流呢?
为了让对象在文件中持久存储，或者在网络中传输。
序列化流：ObjectOutputStream	
反序列化流：ObjectInputStream	(把流数据的对象还原)

Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。
属性列表中每个键及其对应值都是一个字符串。 

线程是依赖于进程而存在的。
进程：进程就是正在运行的程序，是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源

多进程有什么意义呢?
 
   多进程的作用不是提高执行速度，而是提高CPU的使用率。

   单核计算机：CPU多个进程间进行高效的切换，在任意一个时刻，只能有一个进程运行。


线程：线程是程序中单个顺序的控制流，是程序使用CPU的基本单位。
多线程有什么意义呢?

   多线程的作用不是提高执行速度，而是为了提高应用程序的使用率。
 
   因为多个线程共享同一个进程的资源(堆内存和方法区)，但是栈内存是独立的，一个线程一个栈。

   所以他们仍然是在抢CPU的资源执行。一个时间点上只有能有一个线程执行。而且谁抢到，这个不一定，所以，造成了线程运行的随机性。

并行和并发。
 
   前者是逻辑上同时发生，指在某一个时间内同时运行多个程序。
   后者是物理上同时发生，指在某一个时间点同时运行多个程序。
 
   那么，我们能不能实现真正意义上的并发呢，是可以的，多个CPU就可以实现，不过你得知道如何调度和控制它们。
 *
 

多线程概述

   进程：

     正在运行的程序，是系统进行资源分配和调用的独立单位。
     每一个进程都有它自己的内存空间和系统资源。
 
   线程：
 
     是进程中的单个顺序控制流，是一条执行路径
 
     一个进程如果只有一条执行路径，则称为单线程程序。

     一个进程如果有多条执行路径，则称为多线程程序。

线程的调度：两种
 
分时调度模型   平均分配
抢占式调度模型   谁优先级高谁先执行


java采用的是抢占式调度模型。


java是如何获取和设置线程的优先级呢?
 
我们现在并没有给出每个线程的优先级，但是，它一样可以跑。说明了，它应该是有默认优先级。
 
public final int getPriority():返回线程的优先级。 通过测试，我们知道线程的默认优先级是5
 
public final void setPriority(int newPriority):更改线程的优先级。 通过查看源码，我们知道线程的优先级范围是：1-10。默认是5


线程的优先级高，不代表一定会先执行完毕。只有在次数特别多的情况下，才能体现出来。

join() :等待该线程终止
stop():直接死
interrupt():死后还可以写遗嘱
yield():礼让线程,暂停当前正在执行的线程对象，并执行其他线程。

为了更符合现实情况，我们加一些延迟。
当我们加入了一些延时之后，出现了两个问题：
A:相同的票出现了多次

   CPU的一次操作必须是原子性的
 
B:还出现了负数票的情况

   随机性和延迟导致的
 

为什么会有这样的问题产生呢?什么情况下会产生线程安全问题呢?

A:多线程环境
B:有共享数据
C:多条语句操作共享数据

那么我们该如何解决呢?
我们把有多条语句操作共享数据的地方给包围起来。然后这就是一个整体了。

然后把这个整体给锁起来，就可以解决这个问题了。

关键是如何锁起来呢?
这个时候，java就提供了一个技术：同步代码块。
synchronized(对象){
   需要同步的代码;
}

对象到底是什么东西呢? 就是锁。多个线程的锁对象必须一致。

同步代码块的对象可以是哪些呢?
可以是任意的对象

设计模式：经验的总结。是一套模型。
创建型模式，行为型模式，结构型模式

单例模式：保证类在内存中只有一个对象。

如何能够保证类在内存中只有一个对象呢?
A:让外界不能创建对象---构造私有
B:本身提供一个对象---在成员位置创建对象
C:对外提供公共的访问方式---写一个公共方法即可


饿汉式：加载的时候就创建对象
懒汉式：在用的时候再去创建对象，线程安全问题，延迟加载思想(什么时候用，什么时候加载)

死锁：是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待现象

解决线程安全问题,怎么解决呢?
上锁。同步代码块。

注意：
A:不同种类的线程操作的时候，要加锁，同时都要加。
B:不但同时加锁，还要求锁是同一把


为什么这些方法定义到了Object类中呢?
因为调用这些方法都必须通过锁对象调用，而同步代码块的锁对象是任意对象。所以定义在了Object类。

线程组：Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。

线程池：线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。
步骤：
A:定义类MyRunnable实现Runnable接口
B:创建MyRunnable对象
C:创建线程池对象
D:提交
E:释放


线程组：线程组存在的意义，首要原因是安全。java默认创建的线程都是属于系统线程组，而同一个线程组的线程是可以相互修改对方的数据的。但如果在不同的线程组中，那么就不能“跨线程组”修改数据，可以从一定程度上保证数据安全。
线程池：线程池存在的意义，首要作用是效率。线程的创建和结束都需要耗费一定的系统时间（特别是创建），不停创建和删除线程会浪费大量的时间。所以，在创建出一条线程并使其在执行完任务后不结束，而是使其进入休眠状态，在需要用时再唤醒，那么 就可以节省一定的时间。如果这样的线程比较多，那么就可以使用线程池来进行管理。保证效率。

线程组和线程池共有的特点：1,都是管理一定数量的线程2,都可以对线程进行控制---包括休眠，唤醒，结束，创建，中断（暂停）--但并不一定包含全部这些操作。

匿名内部类的方式开启多线程程序。

Component：组件，就是一个对象
基本组件	一个具有独立功能的组件，但是要依赖于容器组件存在
容器组件	可以存储基本组件和容器组件的组件

通过观察，我们知道了这样的两个小问题
A:窗体在内存中存在了，只不过我们没有看到
B:创建的存在也是开启了线程的